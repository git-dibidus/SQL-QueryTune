# SQL QueryTune Application – Design Document

## 1. Product Overview

### Introduction

The SQL QueryTune Application is a Windows desktop tool designed to help database professionals analyze and optimize SQL queries for Microsoft SQL Server. The application leverages the robust capabilities of the `QueryTune.Core` library to provide actionable insights, performance metrics, and optimization recommendations through an intuitive user interface.

### Core Features

#### 1. Connection Management

- **User-Friendly Connection Setup**
  - **Server Name Field:** Text input for specifying the SQL Server instance.
  - **Database Name Field:** Text input for selecting the target database.
  - **Authentication Mode:**
    - **Windows Authentication:** Option for integrated security.
    - **SQL Server Authentication:** Option to enter User ID and Password.
      - **Conditional Fields:** User ID and Password fields are only visible when SQL Server Authentication is selected.
  - **Test Connection Button:** Validates the entered connection parameters and provides immediate feedback (success/failure message).

#### 2. Query Input and Analysis

- **SQL Query Input Panel**
  - Multi-line text box for entering or pasting the SQL query to be analyzed.
  - Syntax highlighting and basic validation (optional enhancement).
- **Run Analysis Button**
  - Triggers the analysis process using the current connection and query.
  - Disables while analysis is running to prevent duplicate submissions.

#### 3. Results Display

- **Analysis Results Panel**
  - Displays the HTML report generated by `QueryTune.Core`.
  - Supports rich formatting, including tables, color-coded suggestions, and code snippets.
  - Automatically clears previous results when a new analysis is started.

### Requirements

#### Functional Requirements

- **Responsive UI:** The application should remain responsive during analysis (consider background processing).
- **Error Handling:** Clear error messages for connection failures, invalid queries, or analysis errors.
- **Security:** Password fields should mask input; sensitive data should not be logged or stored insecurely.
- **Accessibility:** Keyboard navigation and screen reader support for all controls.

#### Non-Functional Requirements

- **Platform:** Windows desktop application (WPF, .NET 8.0).
- **Performance:** Analysis should complete within a reasonable time for typical queries (<10 seconds).
- **Extensibility:** Modular design to allow future enhancements.

## 2. Technical Design

### Architecture

The application will follow the MVVM (Model-View-ViewModel) architectural pattern using the CommunityToolkit.Mvvm library and dependency injection for services and view models.

#### Technology Stack

- **Framework**: .NET 8.0, WPF
- **MVVM Library**: CommunityToolkit.Mvvm
- **Dependency Injection**: Microsoft.Extensions.DependencyInjection
- **Core Analysis Engine**: QueryTune.Core library

### Component Design

#### Models

##### `ConnectionParameters`

```csharp
public class ConnectionParameters
{
    public string ServerName { get; set; }
    public string DatabaseName { get; set; }
    public bool UseWindowsAuthentication { get; set; } = true;
    public string UserId { get; set; }
    public string Password { get; set; }
    
    public string BuildConnectionString()
    {
        // Logic to build connection string based on parameters
    }
}
```

##### `AnalysisResult`

```csharp
public class AnalysisResult
{
    public string HtmlReport { get; set; }
    public bool IsSuccess { get; set; }
    public string ErrorMessage { get; set; }
}
```

#### Services

##### `IDatabaseConnectionService`

```csharp
public interface IDatabaseConnectionService
{
    Task<bool> TestConnectionAsync(ConnectionParameters parameters);
    string GetConnectionString(ConnectionParameters parameters);
}
```

##### `IQueryAnalysisService`

```csharp
public interface IQueryAnalysisService
{
    Task<AnalysisResult> AnalyzeQueryAsync(string connectionString, string sqlQuery);
}
```

##### Implementation: `QueryAnalysisService`

```csharp
public class QueryAnalysisService : IQueryAnalysisService
{
    public async Task<AnalysisResult> AnalyzeQueryAsync(string connectionString, string sqlQuery)
    {
        try
        {
            var optimizer = new SqlQueryOptimizer(connectionString);
            string report = await Task.Run(() => optimizer.AnalyzeAndOptimize(sqlQuery));
            
            return new AnalysisResult
            {
                HtmlReport = report,
                IsSuccess = true
            };
        }
        catch (Exception ex)
        {
            return new AnalysisResult
            {
                IsSuccess = false,
                ErrorMessage = ex.Message
            };
        }
    }
}
```

#### ViewModels

##### `MainViewModel`

```csharp
public partial class MainViewModel : ObservableObject
{
    private readonly IDatabaseConnectionService _connectionService;
    private readonly IQueryAnalysisService _analysisService;
    
    [ObservableProperty]
    private ConnectionParameters _connectionParameters = new();
    
    [ObservableProperty]
    private string _sqlQuery = string.Empty;
    
    [ObservableProperty]
    private string _resultHtml = string.Empty;
    
    [ObservableProperty]
    private bool _isAnalyzing = false;
    
    [ObservableProperty]
    private string _statusMessage = string.Empty;
    
    public MainViewModel(
        IDatabaseConnectionService connectionService,
        IQueryAnalysisService analysisService)
    {
        _connectionService = connectionService;
        _analysisService = analysisService;
    }
    
    [RelayCommand]
    private async Task TestConnectionAsync()
    {
        // Implement test connection logic
    }
    
    [RelayCommand]
    private async Task RunAnalysisAsync()
    {
        // Implement analysis logic
    }
}
```

### UI Design

#### MainWindow Layout

The main window will be divided into two columns:

1. **Main Area** (Left, larger portion)
   - **Query Panel** (Top)
   - **Results Panel** (Bottom)

2. **Connection Panel** (Right, narrow column)
   - All connection controls stacked vertically

```
+-----------------------------------------------+-----------------+
|                                               |                 |
|              Query Panel                      | Connection Panel|
|         [Text Area for SQL Query]             | Server:         |
|                                               | [_____________] |
|                                               |                 |
|         [Run Analysis]                        | Database:       |
|                                               | [_____________] |
+-----------------------------------------------+                 |
|                                               | ○ Windows Auth  |
|                                               | ○ SQL Auth      |
|                                               |                 |
|              Results Panel                    | UserID:         |
|       [WebBrowser/HTML Viewer                 | [_____________] |
|        for Results]                           |                 |
|                                               | Password:       |
|                                               | [*************] |
|                                               |                 |
|                                               | [Test Connect]  |
|                                               |                 |
+-----------------------------------------------+-----------------+
|                       Status Bar                                |
+---------------------------------------------------------------+
```

#### UI Components

##### Connection Panel (Right Column)

- **TextBox**: Server name input
- **TextBox**: Database name input 
- **RadioButton Group**: Authentication mode (Windows/SQL)
- **TextBox**: User ID (visible only when SQL Auth selected)
- **PasswordBox**: Password (visible only when SQL Auth selected)
- **Button**: Test Connection

All controls will be stacked vertically and aligned to create a narrow but functional panel.

##### Query Panel (Top of Main Area)

- **TextBox**: Multi-line text box for SQL query input
- **Button**: Run Analysis

##### Results Panel (Bottom of Main Area)

- **WebBrowser/HTML Viewer**: Displays the HTML report
- **Progress Indicator**: Shows when analysis is running

##### Status Bar (Bottom)

- **TextBlock**: Displays status messages and errors

#### XAML Structure

```xaml
<Grid>
    <Grid.ColumnDefinitions>
        <ColumnDefinition Width="*" />
        <ColumnDefinition Width="Auto" />
    </Grid.ColumnDefinitions>
    <Grid.RowDefinitions>
        <RowDefinition Height="*" />
        <RowDefinition Height="Auto" />
    </Grid.RowDefinitions>

    <!-- Main Area (Left Column) -->
    <Grid Grid.Column="0" Grid.Row="0">
        <Grid.RowDefinitions>
            <RowDefinition Height="*" />
            <RowDefinition Height="*" />
        </Grid.RowDefinitions>

        <!-- Query Panel -->
        <DockPanel Grid.Row="0" Margin="5">
            <Button DockPanel.Dock="Bottom" Content="Run Analysis" Command="{Binding RunAnalysisCommand}" Margin="0,5,0,0" />
            <TextBox Text="{Binding SqlQuery}" AcceptsReturn="True" TextWrapping="Wrap" />
        </DockPanel>

        <!-- Results Panel -->
        <Border Grid.Row="1" BorderBrush="Gray" BorderThickness="0,1,0,0">
            <WebBrowser x:Name="ResultsViewer" />
        </Border>
    </Grid>

    <!-- Connection Panel (Right Column) -->
    <Border Grid.Column="1" Grid.Row="0" BorderBrush="Gray" BorderThickness="1,0,0,0" MinWidth="200" MaxWidth="250">
        <StackPanel Margin="10">
            <TextBlock Text="Server:" Margin="0,5,0,2" />
            <TextBox Text="{Binding ConnectionParameters.ServerName}" />
            
            <TextBlock Text="Database:" Margin="0,10,0,2" />
            <TextBox Text="{Binding ConnectionParameters.DatabaseName}" />
            
            <StackPanel Margin="0,10,0,0">
                <RadioButton Content="Windows Authentication" 
                             IsChecked="{Binding ConnectionParameters.UseWindowsAuthentication}" 
                             Margin="0,0,0,5" />
                <RadioButton Content="SQL Server Authentication" 
                             IsChecked="{Binding Path=ConnectionParameters.UseWindowsAuthentication, Converter={StaticResource InverseBoolConverter}}" />
            </StackPanel>
            
            <TextBlock Text="User ID:" Margin="0,10,0,2" 
                       Visibility="{Binding ConnectionParameters.UseWindowsAuthentication, Converter={StaticResource BoolToVisibilityConverter}, ConverterParameter=inverse}" />
            <TextBox Text="{Binding ConnectionParameters.UserId}" 
                     Visibility="{Binding ConnectionParameters.UseWindowsAuthentication, Converter={StaticResource BoolToVisibilityConverter}, ConverterParameter=inverse}" />
            
            <TextBlock Text="Password:" Margin="0,10,0,2" 
                       Visibility="{Binding ConnectionParameters.UseWindowsAuthentication, Converter={StaticResource BoolToVisibilityConverter}, ConverterParameter=inverse}" />
            <PasswordBox x:Name="PasswordBox" 
                         Visibility="{Binding ConnectionParameters.UseWindowsAuthentication, Converter={StaticResource BoolToVisibilityConverter}, ConverterParameter=inverse}" />
            
            <Button Content="Test Connection" Command="{Binding TestConnectionCommand}" Margin="0,15,0,0" />
        </StackPanel>
    </Border>

    <!-- Status Bar -->
    <StatusBar Grid.Column="0" Grid.Row="1" Grid.ColumnSpan="2">
        <TextBlock Text="{Binding StatusMessage}" />
    </StatusBar>
</Grid>
```

### Application Workflow

1. **Startup**:
   - Application initializes and displays the main window
   - Connection panel is ready for input
   - Query and Results panels are empty

2. **Connection Setup**:
   - User enters server and database information
   - User selects authentication mode
   - If SQL Auth, user provides credentials
   - User clicks "Test Connection" to validate

3. **Query Analysis**:
   - User enters SQL query in the Query Panel
   - User clicks "Run Analysis"
   - Application shows progress indicator
   - Application calls QueryTune.Core via service
   - Results are displayed in the Results Panel

4. **Error Handling**:
   - Connection errors are displayed in status bar
   - Analysis errors are displayed in status bar or Results Panel

### Dependency Injection Setup

```csharp
// In App.xaml.cs
protected override void OnStartup(StartupEventArgs e)
{
    base.OnStartup(e);
    
    var services = new ServiceCollection();
    
    // Register services
    services.AddSingleton<IDatabaseConnectionService, DatabaseConnectionService>();
    services.AddSingleton<IQueryAnalysisService, QueryAnalysisService>();
    
    // Register view models
    services.AddTransient<MainViewModel>();
    
    // Register views
    services.AddTransient(serviceProvider => 
        new MainWindow
        {
            DataContext = serviceProvider.GetRequiredService<MainViewModel>()
        });
    
    var serviceProvider = services.BuildServiceProvider();
    
    // Show main window
    var mainWindow = serviceProvider.GetRequiredService<MainWindow>();
    mainWindow.Show();
}
```

### Technical Implementation Details

#### Two-Way Binding

- Use two-way binding for connection parameters and SQL query input

#### Visibility Logic

- Use visibility converters to show/hide SQL Authentication fields based on authentication mode selection

#### HTML Report Display

- Use a WebBrowser control or HTML viewer control to render HTML reports
- Consider a third-party control for better HTML rendering (such as CefSharp)

#### Background Processing

- Run analysis operations on background threads to keep UI responsive
- Use async/await pattern for all potentially long-running operations

#### Error Handling

- Implement comprehensive try/catch blocks in services
- Display user-friendly error messages in the UI
- Log detailed errors for troubleshooting

#### Responsive Layout

- The main area will use star sizing (`*`) to take maximum available space
- The connection panel will use `Auto` width with min/max constraints to ensure it remains narrow but usable
- Grid splitters could be added between the query and results panels to allow users to adjust the ratio

#### Connection Panel Styling

- Consider using GroupBoxes or Expanders to organize the connection panel for better visual structure
- Apply consistent margins and padding to ensure controls are properly spaced in the vertical stack

#### Scrolling

- Ensure both the query and results panels have scrolling capabilities for handling large queries and reports
- The connection panel should also be scrollable if the window height is reduced

## 3. Future Enhancements

### Query History & Management

- **Query History:** Save and recall previously analyzed queries.
- **Favorites:** Mark and organize frequently used queries.

### Report Export & Sharing

- **Export to PDF/HTML:** Allow users to save or print analysis reports.
- **Copy to Clipboard:** Quick copy of the HTML report or recommendations.

### Advanced Analysis Options

- **Batch Analysis:** Analyze multiple queries or scripts in sequence.
- **Parameterization Support:** Allow users to define and substitute query parameters.
- **Customizable Thresholds:** Let users adjust thresholds for what constitutes "expensive" operations.

### Integration & Automation

- **Command-Line Interface:** Run analyses from scripts or CI/CD pipelines.
- **API Integration:** Expose analysis as a REST API for integration with other tools.

### Visualization Enhancements

- **Execution Plan Visualization:** Graphical representation of the execution plan.
- **Performance Trends:** Track and visualize performance metrics over time.

### User Experience Improvements

- **Intelligent Suggestions:** Context-aware recommendations based on user's environment.
- **In-app Documentation:** Embedded help and tooltips for all features.

## 4. Testing Strategy

- Unit tests for ViewModels and Services
- Integration tests for QueryTune.Core interactions
- UI automation tests for critical user workflows

## 5. Next Steps

1. Implement base application structure and DI setup
2. Implement Connection Panel functionality
3. Implement Query Panel functionality
4. Implement Results Panel and HTML rendering
5. Add error handling and status reporting
6. Perform integration testing with QueryTune.Core

## 6. Summary Table of Features

| Feature                        | Description                                                      | Status      |
|------------------------------- |------------------------------------------------------------------|-------------|
| Connection String Builder      | Guided input for server, database, authentication                | Required    |
| Test Connection                | Validate connection parameters                                   | Required    |
| SQL Query Input                | Panel for entering SQL queries                                   | Required    |
| Run Analysis                   | Button to trigger analysis                                       | Required    |
| Results Panel                  | HTML report display                                              | Required    |
| Error Handling                 | User-friendly error messages                                     | Required    |
| Query History                  | Save and recall past queries                                     | Future      |
| Export/Share Report            | Export analysis results to PDF/HTML                              | Future      |
| Batch Analysis                 | Analyze multiple queries at once                                 | Future      |
| Execution Plan Visualization   | Graphical plan viewer                                            | Future      |
| Customizable Analysis Settings | User-defined thresholds and options                              | Future      |

## 7. Conclusion

The SQL QueryTune Application aims to make SQL query optimization accessible and actionable for all users, from developers to DBAs. By combining a user-friendly interface with the analytical power of the `QueryTune.Core` library, the application will help users quickly identify performance bottlenecks and implement best practices for SQL Server query optimization.

The application will follow modern design principles using MVVM architecture and dependency injection, ensuring it remains maintainable and extensible as new features are added in the future.

Similar code found with 1 license type